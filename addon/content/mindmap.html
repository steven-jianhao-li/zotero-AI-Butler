<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Butler Mindmap</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #ffffff;
      }
      .toolbar {
        display: flex;
        gap: 8px;
        padding: 8px;
        background: #f5f5f5;
        border-bottom: 1px solid #e0e0e0;
      }
      .toolbar button {
        padding: 6px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
      }
      .toolbar button:hover {
        background: #f0f0f0;
      }
      .toolbar button.primary {
        background: #4caf50;
        color: white;
        border-color: #4caf50;
      }
      .toolbar button.primary:hover {
        background: #45a049;
      }
      #mindmap-container {
        width: 100%;
        height: calc(100% - 50px);
        overflow: hidden;
      }
      #mindmap-svg {
        width: 100%;
        height: 100%;
      }
      .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        color: #666;
        font-size: 14px;
      }
      .error {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        color: #d32f2f;
        font-size: 14px;
        padding: 20px;
        text-align: center;
      }
    </style>
    <!-- æœ¬åœ°æ‰“åŒ…çš„ markmap bundleï¼ˆåŒ…å« d3, markmap-lib, markmap-viewï¼‰-->
    <script src="markmap-bundle.js"></script>
  </head>
  <body>
    <div class="toolbar">
      <button id="zoom-out" title="ç¼©å°">â–</button>
      <button id="zoom-in" title="æ”¾å¤§">â•</button>
      <button id="fit" title="é€‚åº”ç”»å¸ƒ">ğŸ¯</button>
      <button id="open-window" title="æ‰“å¼€é¢„è§ˆçª—å£">â›¶</button>
      <button id="export-png" class="primary" title="å¯¼å‡ºä¸ºPNGå›¾ç‰‡">
        ğŸ“· PNG
      </button>
      <button id="export-opml" class="primary" title="å¯¼å‡ºä¸ºOPMLå¤§çº²">
        ğŸ“„ OPML
      </button>
    </div>
    <div id="mindmap-container">
      <div class="loading">æ­£åœ¨åŠ è½½æ€ç»´å¯¼å›¾...</div>
    </div>

    <script>
      let markmap = null;
      let currentMarkdown = "";

      // åˆå§‹åŒ–æ€ç»´å¯¼å›¾
      function initMindmap(markdown) {
        currentMarkdown = markdown;
        const container = document.getElementById("mindmap-container");

        try {
          // æ¸…ç©ºå®¹å™¨
          container.innerHTML = "";

          // åˆ›å»º SVG å…ƒç´ 
          const svg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "svg",
          );
          svg.id = "mindmap-svg";
          container.appendChild(svg);

          // ä½¿ç”¨ markmap æ¸²æŸ“
          const { Transformer } = window.markmap;
          const transformer = new Transformer();
          const { root } = transformer.transform(markdown);

          // åˆ›å»º Markmap å®ä¾‹
          const { Markmap } = window.markmap;
          markmap = Markmap.create(
            svg,
            {
              autoFit: true,
              duration: 500,
              maxWidth: 300,
            },
            root,
          );

          console.log("[AI-Butler Mindmap] æ¸²æŸ“æˆåŠŸ");
        } catch (err) {
          console.error("[AI-Butler Mindmap] æ¸²æŸ“å¤±è´¥:", err);
          container.innerHTML =
            '<div class="error">æ¸²æŸ“å¤±è´¥: ' + err.message + "</div>";
        }
      }

      // ç¼©æ”¾æ§åˆ¶
      document.getElementById("zoom-out").addEventListener("click", () => {
        if (markmap) {
          const svg = document.getElementById("mindmap-svg");
          const transform = markmap.svg.node().__zoom || d3.zoomIdentity;
          markmap.svg
            .transition()
            .call(markmap.zoom.transform, transform.scale(0.8));
        }
      });

      document.getElementById("zoom-in").addEventListener("click", () => {
        if (markmap) {
          const svg = document.getElementById("mindmap-svg");
          const transform = markmap.svg.node().__zoom || d3.zoomIdentity;
          markmap.svg
            .transition()
            .call(markmap.zoom.transform, transform.scale(1.25));
        }
      });

      document.getElementById("fit").addEventListener("click", () => {
        if (markmap) {
          markmap.fit();
        }
      });

      // åœ¨ä¾§è¾¹æ  iframe ä¸­æ˜¾ç¤º"æ‰“å¼€é¢„è§ˆçª—å£"æŒ‰é’®ï¼›åœ¨ç‹¬ç«‹é¢„è§ˆçª—å£ä¸­éšè—
      (function () {
        const openBtn = document.getElementById("open-window");
        if (!openBtn) return;

        const isViewerMode = (() => {
          try {
            const params = new URLSearchParams(window.location.search);
            return params.get("mode") === "viewer";
          } catch (e) {
            return false;
          }
        })();

        // é¡¶å±‚çª—å£ï¼ˆé iframeï¼‰æˆ– viewer æ¨¡å¼ä¸‹ï¼Œä¸éœ€è¦è¯¥æŒ‰é’®
        const isTopLevel = (() => {
          try {
            return window.parent === window;
          } catch (e) {
            return true;
          }
        })();

        if (isViewerMode || isTopLevel) {
          openBtn.style.display = "none";
          return;
        }

        openBtn.addEventListener("click", () => {
          try {
            window.parent.postMessage({ type: "open-mindmap-viewer" }, "*");
          } catch (e) {}
        });
      })();

      // PNG å¯¼å‡ºåŠŸèƒ½
      document
        .getElementById("export-png")
        .addEventListener("click", async () => {
          if (!markmap) return;

          const exportBtn = document.getElementById("export-png");
          exportBtn.textContent = "â³ å¯¼å‡ºä¸­...";
          exportBtn.disabled = true;

          try {
            const svg = document.getElementById("mindmap-svg");

            // è·å– SVG çš„å®é™…è¾¹ç•Œ
            const bbox = svg.getBBox();
            const padding = 60;

            // è®¡ç®—å®Œæ•´å°ºå¯¸
            const svgWidth = bbox.width + padding * 2;
            const svgHeight = bbox.height + padding * 2;

            // åˆ›å»ºæ–°çš„ SVG å­—ç¬¦ä¸²ï¼Œç›´æ¥åŒ…å«å®Œæ•´å†…å®¹
            const svgClone = svg.cloneNode(true);

            // è®¾ç½®æ­£ç¡®çš„ viewBox ä»¥åŒ…å«æ‰€æœ‰å†…å®¹
            svgClone.setAttribute("width", svgWidth);
            svgClone.setAttribute("height", svgHeight);
            svgClone.setAttribute(
              "viewBox",
              `${bbox.x - padding} ${bbox.y - padding} ${svgWidth} ${svgHeight}`,
            );
            svgClone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svgClone.setAttribute(
              "xmlns:xlink",
              "http://www.w3.org/1999/xlink",
            );

            // ç§»é™¤æ‰€æœ‰ class å±æ€§å¹¶å†…è”å…³é”®æ ·å¼
            svgClone.querySelectorAll("*").forEach((el) => {
              // ä¿ç•™ fill, stroke ç­‰å…³é”®å±æ€§
              let originalEl = el;
              try {
                // å°è¯•é€šè¿‡ id æŸ¥æ‰¾å¯¹åº”å…ƒç´ 
                const elId = el.id;
                if (elId && elId.length > 0) {
                  const found = svg.querySelector(`#${CSS.escape(elId)}`);
                  if (found) originalEl = found;
                }
              } catch (e) {}

              if (originalEl && window.getComputedStyle) {
                try {
                  const cs = window.getComputedStyle(originalEl);
                  const fill = cs.fill || cs.getPropertyValue("fill");
                  const stroke = cs.stroke || cs.getPropertyValue("stroke");
                  const strokeWidth =
                    cs.strokeWidth || cs.getPropertyValue("stroke-width");

                  if (fill && fill !== "none") el.setAttribute("fill", fill);
                  if (stroke && stroke !== "none")
                    el.setAttribute("stroke", stroke);
                  if (strokeWidth) el.setAttribute("stroke-width", strokeWidth);
                } catch (e) {}
              }
            });

            // åœ¨å¼€å¤´æ’å…¥ç™½è‰²èƒŒæ™¯çŸ©å½¢
            const bgRect = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect",
            );
            bgRect.setAttribute("x", bbox.x - padding);
            bgRect.setAttribute("y", bbox.y - padding);
            bgRect.setAttribute("width", svgWidth);
            bgRect.setAttribute("height", svgHeight);
            bgRect.setAttribute("fill", "#ffffff");
            svgClone.insertBefore(bgRect, svgClone.firstChild);

            const svgString = new XMLSerializer().serializeToString(svgClone);

            // ä½¿ç”¨ Data URL æ–¹å¼
            const svgBase64 = btoa(unescape(encodeURIComponent(svgString)));
            const imgSrc = `data:image/svg+xml;base64,${svgBase64}`;

            const canvas = document.createElement("canvas");
            const scale = 2; // é«˜æ¸…
            canvas.width = svgWidth * scale;
            canvas.height = svgHeight * scale;

            const ctx = canvas.getContext("2d");
            ctx.scale(scale, scale);
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, svgWidth, svgHeight);

            const img = new Image();
            img.onload = () => {
              ctx.drawImage(img, 0, 0, svgWidth, svgHeight);

              const dataUrl = canvas.toDataURL("image/png");

              window.parent.postMessage(
                {
                  type: "export-mindmap",
                  format: "png",
                  dataUrl: dataUrl,
                  filename: "mindmap-" + Date.now() + ".png",
                },
                "*",
              );

              console.log("[AI-Butler Mindmap] PNG å¯¼å‡ºå®Œæˆ");
              exportBtn.textContent = "ğŸ“· PNG";
              exportBtn.disabled = false;
            };

            img.onerror = (e) => {
              console.error("Failed to load SVG image:", e);
              exportBtn.textContent = "ğŸ“· PNG";
              exportBtn.disabled = false;
            };

            img.src = imgSrc;
          } catch (err) {
            console.error("[AI-Butler Mindmap] PNG å¯¼å‡ºå¤±è´¥:", err);
            exportBtn.textContent = "ğŸ“· PNG";
            exportBtn.disabled = false;
          }
        });

      // OPML å¯¼å‡ºåŠŸèƒ½
      document
        .getElementById("export-opml")
        .addEventListener("click", async () => {
          if (!currentMarkdown) return;

          const exportBtn = document.getElementById("export-opml");
          exportBtn.textContent = "â³ å¯¼å‡ºä¸­...";
          exportBtn.disabled = true;

          try {
            // å°† Markdown è½¬æ¢ä¸º OPML
            const opmlContent = markdownToOpml(currentMarkdown);

            // å‘é€åˆ°çˆ¶çª—å£å¤„ç†ä¿å­˜
            window.parent.postMessage(
              {
                type: "export-mindmap",
                format: "opml",
                content: opmlContent,
                filename: "mindmap-" + Date.now() + ".opml",
              },
              "*",
            );

            console.log("[AI-Butler Mindmap] OPML å¯¼å‡ºæ•°æ®å·²å‘é€");
            exportBtn.textContent = "ğŸ“„ OPML";
            exportBtn.disabled = false;
          } catch (err) {
            console.error("[AI-Butler Mindmap] OPML å¯¼å‡ºå¤±è´¥:", err);
            exportBtn.textContent = "ğŸ“„ OPML";
            exportBtn.disabled = false;
          }
        });

      // Markdown è½¬ OPML å‡½æ•°
      function markdownToOpml(markdown) {
        const lines = markdown.split("\n").filter((l) => l.trim());
        let opml = `<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title>æ€ç»´å¯¼å›¾</title>
    <dateCreated>${new Date().toISOString()}</dateCreated>
  </head>
  <body>
`;

        const stack = [{ indent: -1, closed: false }];

        for (const line of lines) {
          let text = "";
          let level = 0;

          // è§£ææ ‡é¢˜
          const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
          if (headerMatch) {
            level = headerMatch[1].length - 1;
            text = headerMatch[2].trim();
          } else {
            // è§£æåˆ—è¡¨é¡¹
            const listMatch = line.match(/^(\s*)[-*+]\s+(.+)$/);
            if (listMatch) {
              level = Math.floor(listMatch[1].length / 2) + 3;
              text = listMatch[2].trim();
            }
          }

          if (!text) continue;

          // å…³é—­æ›´æ·±å±‚çº§çš„èŠ‚ç‚¹
          while (stack.length > 1 && stack[stack.length - 1].indent >= level) {
            const item = stack.pop();
            if (!item.closed) {
              opml += "    ".repeat(stack.length + 1) + "</outline>\n";
            }
          }

          // æ·»åŠ æ–°èŠ‚ç‚¹
          const escapedText = text
            .replace(/&/g, "&amp;")
            .replace(/"/g, "&quot;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
          opml +=
            "    ".repeat(stack.length + 1) +
            `<outline text="${escapedText}">\n`;
          stack.push({ indent: level, closed: false });
        }

        // å…³é—­æ‰€æœ‰å‰©ä½™èŠ‚ç‚¹
        while (stack.length > 1) {
          stack.pop();
          opml += "    ".repeat(stack.length + 1) + "</outline>\n";
        }

        opml += `  </body>
</opml>`;

        return opml;
      }

      // ç›‘å¬æ¥è‡ªçˆ¶çª—å£çš„æ¶ˆæ¯
      window.addEventListener("message", (event) => {
        if (event.data && event.data.type === "render-mindmap") {
          initMindmap(event.data.markdown);
        }
      });

      // é€šçŸ¥çˆ¶çª—å£å·²åŠ è½½å®Œæˆ
      window.parent.postMessage({ type: "mindmap-ready" }, "*");
    </script>
  </body>
</html>
